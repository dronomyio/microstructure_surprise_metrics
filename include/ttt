#pragma once

#include <vector>
#include <memory>
#include <chrono>
#include <cstdint>
#include <cuda_runtime.h>

namespace surprise_metrics {

using timestamp_t = std::chrono::nanoseconds;
using price_t = double;
using volume_t = uint64_t;

// Aligned memory for SIMD operations
template<typename T, std::size_t Alignment>
class aligned_allocator {
public:
    using value_type = T;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    
    template<typename U>
    struct rebind {
        using other = aligned_allocator<U, Alignment>;
    };
    
    aligned_allocator() noexcept = default;
    
    template<typename U>
    aligned_allocator(const aligned_allocator<U, Alignment>&) noexcept {}
    
    T* allocate(size_type n) {
        void* ptr = nullptr;
        if (posix_memalign(&ptr, Alignment, n * sizeof(T)) != 0) {
            throw std::bad_alloc();
        }
        return static_cast<T*>(ptr);
    }
    
    void deallocate(T* ptr, size_type) noexcept {
        free(ptr);
    }
};

template<typename T>
using aligned_vector = std::vector<T, aligned_allocator<T, 64>>;

struct Trade {
    timestamp_t timestamp;
    price_t price;
    volume_t size;
    char exchange;
    uint8_t conditions[4];
} __attribute__((packed));

struct Quote {
    timestamp_t timestamp;
    price_t bid_price;
    price_t ask_price;
    volume_t bid_size;
    volume_t ask_size;
    char bid_exchange;
    char ask_exchange;
} __attribute__((packed));

struct SurpriseMetrics {
    float standardized_return;
    float lee_mykland_stat;
    float bns_stat;
    float trade_intensity_zscore;
    bool jump_detected;
    timestamp_t timestamp;
};

class MetricsCalculator {
public:
    MetricsCalculator(int num_gpus = 1, size_t buffer_size = 1000000);
    ~MetricsCalculator();

    // Main processing functions
    void process_trades(const std::vector<Trade>& trades);
    void process_quotes(const std::vector<Quote>& quotes);
    
    // Get computed metrics
    std::vector<SurpriseMetrics> get_metrics() const;
    
    // Configuration
    void set_garch_params(double omega, double alpha, double beta);
    void set_jump_threshold(double threshold);
    void set_window_size(int window);

private:
    class Impl;
    std::unique_ptr<Impl> pImpl;
};

// SIMD optimized functions
namespace simd {
    void compute_returns_avx512(const float* prices, float* returns, size_t n);
    void compute_realized_variance_avx512(const float* returns, float* rv, size_t n, int window);
    void compute_bipower_variation_avx512(const float* returns, float* bv, size_t n);
}

// CUDA kernel declarations
namespace cuda {
    void launch_garch_estimation(float* returns, float* sigma, int n, 
                                 float omega, float alpha, float beta,
                                 cudaStream_t stream = 0);
    void launch_jump_detection(float* returns, float* local_vol, 
                               bool* jump_flags, int n, float threshold,
                               cudaStream_t stream = 0);
    void launch_hawkes_intensity(float* timestamps, float* intensity, 
                                 int n, float mu, float phi, float kappa,
                                 cudaStream_t stream = 0);
}

} // namespace surprise_metrics
